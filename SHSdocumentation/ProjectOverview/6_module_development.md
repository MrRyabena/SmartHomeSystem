<a id="6_stageI"></a>

# 6. Этап I. Проектирование автоматических модулей

В этом этапе рассказаны принципы построения системы умного дома. В _**Smart Home System**_ алгоритмы управления уже реализованы в ядре и библиотеке (см. [Этап II](#7_stageII) и [Этап III](#8_stageIII)), что упрощает и ускоряет разработку системы.

<a id="6-1_module"></a>

## 6.1 Module

Module — самостоятельный компонент Smart Home System, состоящий из одного или нескольких микроконтроллеров, блока питания, обвязки для управления нагрузками и датчиками для сбора данных.

- Может управлять устройствами и нагрузками.
- Может опрашивать датчики и обрабатывать информацию с них.
- Должен корректно функционировать самостоятельно, при потере связи с другими модулями.
- Должен иметь связь с сервером.</br>

Каждый модуль имеет свой `ID`, по которому к нему можно обратиться, понять, что данные собраны и отправлены им.</br>

Для Module созданы отдельные классы (см. [SHSmodule.h](SHSlibrary/SHSmodule.h)), которые являются удобной оберткой (по сути мини операционной системой), контролирующей модуль и позволяющей по одному шаблону настроить и запустить все процессы, корректно связаться и взаимодействовать с системой. Это позволило вынести одинаковые куски кода по настройке каждого модуля в пару удобных функций.

<a id="6-2_server"></a>

## 6.2 Server

За обработку всех данных, запросов, команд и принятие решений отвечает главный элемент системы — сервер. По идее, в качестве сервера может выступать любое устройство, например, конкретный модуль или компьютер. В _**Smart Home System**_ сервер реализован на отдельном микроконтроллере, т.к. компьютер нет смысла гонять впустую (не выключая) из-за какого-то процесса умного дома, а другие модули заняты своими вычислениями и их мощности будет маловато.</br>

<a id="6-2-1_server_requirements"></a>

### 6.2.1 Основные требования к серверу

- Поддерживать одновременное подключение нескольких устройств по TCP/IP.
- Иметь достаточную вычислительную мощность для быстрой обработки всех данных.
- Иметь хранилище данных (ПЗУ) для сохранения собранной информации и ведения статистики.
- Эффективно и надежно поддерживать непрерывную работу.

Выбранным микроконтроллером стал ESP32, его двухъядерный процессор и достаточно большой объем RAM идеально подходят для работы с TCP/IP и обработкой данных.</br>

<a id="6-3_load"></a>

## 6.3 Управление нагрузкой

<a id="6-3-1_power-circuits"></a>

### 6.3.1 Силовые схемы

Одной из самых главных задач **_Smart Home System_**, является управление различными бытовыми приборами. Для этого, управляющий сигнал микроконтроллера подается на специальные схемы управления мощной нагрузкой. В основном в проекте используются три силовые схемы:

- Полевой транзистор.

  - Подходит для коммутации нагрузки при напряжении 1—30V и токах в несколько А.
  - Поддерживает режимы on/off и PWM (даже на высоких частотах).
  - Может греться при больших токах и высоких частотах, в таком случае требуется теплоотвод.</br>

  _Диод D1 необходим, если нагрузка индуктивная, чтобы не спалить транзистор._

  ![transistor-scheme](schemes/transistor-scheme.png)

- Биполярный транзистор.

  - Практически полностью вытеснен полевиками.
  - Бывает полезен для различных подтяжек к земле (например, контакта PS_ON, для включения компьютерного блока питания) или для управления слаботочными реле.

  ![bc547-scheme](schemes/bc547-scheme.png)

- Реле.
  - Может работать как с низким, так и с высоким напряжением, при постоянном или переменном токе.
  - Поддерживает режим on/off, когда не требуется частых переключений.
  - Издает звуки при работе, в отличии от других компонентов.
  - Имеет короткий срок эксплуатации (за счет физического износа контактов при переключении).</br>

_При большом токе рекомендуется использовать искрогасящие цепи._

![relay-scheme](schemes/relay-scheme.png)

- Симистор.
  - Работает с переменным током.
  - Поддерживает режимы on/off и диммер.
  - Греется при мощной нагрузке.

<a id="6-3-2_modeSWITCH"></a>

### 6.3.2 Режим `SWITCH`

В этом режиме нагрузку можно только включить или выключить.

```c++
#include <Arduino.h>
// set pin for output
pinMode(myPIN, OUTPUT);

// on
digitalWrite(myPIN, HIGH);

// off
digitalWrite(myPIN, LOW);

```

<a id="6-3-3_modePWM"></a>

### 6.3.3 Режим `PWM`

Режим позволят плавно управлять мощностью нагрузки, за счет широтно-импульсной модуляции. Нагрузка получает питание импульсами, а за счет высокой частоты и своей инертности импульсы сглаживаются.</br>

Рекомендуется повысить стандартную частоту PWM, если это позволяет сделать силовая схема (не перегревается). Удобнее всего это сделать с помощью библиотеки [GyverPWM](https://github.com/GyverLibs/GyverPWM), либо вручную установить нужные регистры. **Работает только для ATmega328.** ESP выдают слабый ток и напряжение с пина, поэтому плохо подходят для ШИМ-контроллеров, если очень нужно изменить стандартные настройки — см. документацию на микроконтроллер и его ядро (где-то есть функции, т.к. у ESP8266 ШИМ в принципе реализован программно).</br>

Более подробно можно прочитать в статьях про ШИМ и увеличение его частоты на сайте у [Гайвера](https://alexgyver.ru).

```c++
#include <Arduino.h>
#include <GyverPWM.h>

// optimal settings:
// only ATmega328!
PWM_prescaler(3, 1);
PWM_prescaler(9, 1);
PWM_TMR1_8BIT();

// PWM
// value: [0; 256) (if 8-bit PWM)
analogWrite(myPIN, value);

```

<a id="6-3-4_modeDIMMER"></a>

### 6.3.4 Режим `DIMMER`

Необходим для плавного управления нагрузкой переменного тока.</br>

Удобнее всего использовать библиотеку [GyverDimmer](https://github.com/GyverLibs/GyverDimmer). _Лучше использовать алгоритм Брезенхема._

<a id="6-3-5_modePID"></a>

### 6.3.5 Режим `PID`

Крутой алгоритм для поддержания заданной установки. Требует времени на подбор коэффициентов. Идеален для поддержания инертных процессов (температура, влажность…).</br>

Удобнее всего использовать библиотеку [GyverPID](https://github.com/GyverLibs/GyverPID).

<a id="6-4_sensors"></a>

## 6.4 Датчики

<a id="6-4-1_button"></a>

### 6.4.1 Кнопка, энкодер, потенциометр

Механическая, либо сенсорная кнопка — самый простой датчик, но, несмотря на это, за счет обработки количества и времени нажатий, можно организовать удобное многофункциональное управление устройством.</br>

Для удобной обработки нажатий в проекте используется библиотека [EncButton](https://github.com/GyverLibs/EncButton). Помимо кнопки, она предлагает инструменты для работы с энкодером.</br>

Для обработки потенциометра особых хитростей не надо, достаточно получить значение с АЦП и привести его в нужный диапазон.

```c++
#include <Arduino.h>

pinMode(Apin, INPUT);

int value = analogRead(Apin);
value = map(value, 0, 1023, 0, 100);
// or for [0, 256):
// value >>= 2;
```

<a id="6-4-2_thermistor"></a>

### 6.4.2 Термистор и фоторезистор

Для преобразования показаний **термистора** используется уравнение Стейнхарта—Харта. Можно воспользоваться готовой библиотекой [GyverNTC](https://github.com/GyverLibs/GyverNTC), либо создать функцию самостоятельно.</br>

Для **фоторезистора** нужно измерить показания с АЦП. Других преобразований сделать не получится, единственный вариант — запомнить значения минимальной и максимальной освещенности и перевести в проценты яркости.

<a id="6-4-3_thermocouple"></a>

### 6.4.3 Термопара

С помощью термопары можно измерить высокие температуры в несколько сотен градусов. К ней требуется драйвер-усилитель, для работы с которым есть хорошая библиотека [GyverMAX6675](https://github.com/GyverLibs/GyverMAX6675).

<a id="6-4-4_ds18b20"></a>

### 6.4.4 DS18B20

Достаточно точный цифровой датчик температуры.</br>
Библиотека: [microDS18B20](https://github.com/GyverLibs/microDS18B20)

<a id="6-4-5_htu21d"></a>

### 6.4.5 HTU21D

Точный датчик температуры и влажности воздуха. Для работы с ним есть легкая библиотека [GyverHTU21D](https://github.com/GyverLibs/GyverHTU21D).

<a id="6-4-6_bme280"></a>

### 6.4.6 BME280/BMP280

На основе BME280 можно собрать полноценную метеостанцию, измеряющую температуру, влажность воздуха и атмосферное давление.</br>

Удобная библиотека: [GyverBME280](https://github.com/GyverLibs/GyverBME280).

<a id="6-4-7_mh-z19b"></a>

### 6.4.7 MH-Z19b

Современный датчик, позволяющий определять концентрацию углекислого газа (CO2) в воздухе. Очень полезен для информирования об опасном уровне или организации автоматической форточки (системы проветривания).</br>

По работе с ним есть [статья](https://habr.com/ru/articles/391157/), позже в проекте появится своя библиотека.

<a id="6-4-8_hx711"></a>

### 6.4.8 HX711

Драйвер для различных датчиков веса. Можно отслеживать или отмерять жидкости по весу.</br>

Библиотека: [GyverHX711](https://github.com/GyverLibs/GyverHX711).

<a id="7_stageII"></a>