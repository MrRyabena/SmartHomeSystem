# Гайд по созданию системы

> “In theory there is no difference between theory and practice - in practice there is” — Yogi Berra
> “В теории, теория и практика неразделимы. На практике это не так” — Йоги Берра

В этой статье представлен пример практического применения **_SmartHomeSystem_**. Перед прочтением рекомендуется изучить основную документацию проекта, однако, если вы решили начать знакомство с **_SmartHomeSystem_** именно с этого гайда, то по мере прочтения вы найдете ссылки на материалы, которые пояснят возникающие вопросы.

## Содержание

- [Введение](#введение)
- [Анализ и проектирование системы](#анализ-и-проектирование-системы)
- [Аппаратная часть](#аппаратная-часть)
  - [Выбор компонентов](#выбор-компонентов)
  - [Разработка электрической схемы](#разработка-электронной-схемы)
- [Программная часть](#программная-часть)
  - [Подготовка ПО и сборка](#подготовка-по-и-сборка)
  - [Конфигурация системы](#конфигурация-системы)
  - [Подключение модулей к WiFi](#подключение-модулей-к-wifi)
  - [Настройка DTP](#настройка-dtp)
  - [Реализация модулей](#реализация-модулей)
  - [Разработка GUI](#разработка-gui)
    - [Backend](#backend)
    - [Frontend](#frontend)
    - [Скриншот приложения](#скриншот-приложения)

## Введение

Проектирование любой системы состоит из нескольких этапов:

1. Определение задач, которые будет выполнять система.
2. Выбор компонентов
3. Проектирование узлов и модулей
4. Сборка системы
5. Программирование поведения системы
6. Отладка и настройка

В этом гайде мы рассмотрим пример создания небольшой системы. Конечно, он не охватит все возможности **_SmartHomeSystem_**, но вполне наглядно покажет преимущества проекта.

## Анализ и проектирование системы

> “Simplicity is prerequisite for reliability” — Edsger W. Dijkstra

**_SmartHomeSystem_** — кроссплатформенный фреймворк, который позволяет создавать как полномасштабные системы автоматизации, так и отдельные компоненты и узлы.

В первую очередь необходимо определиться с назначением проектируемой системы. Одно дело, если перед нами стоит задача автоматизировать производство или большой загородный дом с участком. Совсем другое, если необходимо собрать небольшой узел, например, метеостанцию, или управление светом по датчику движения. В любом случае перед началом проектирования важно четко сформулировать, какие задачи будет решать система.

Цель нашей системы — наглядно продемонстрировать возможности **_SmartHomeSystem_**. Хотя данная система не предназначена для решения конкретных практических задач, она показывает, как можно применять **_SmartHomeSystem_** для создания реальных автоматизированных решений.

В **_SmartHomeSystem_**  выделяются три основных компонента, работу с которыми нам предстоит рассмотреть:

- **Load** (нагрузка) — абстракция, отвечающая за включение/выключение или плавное регулирование определенного устройства.
- **Sensor** (датчик) — отвечает за измерение показаний окружающей среды.
- **Data Transfer Protocol** (Протокол Передачи Данных) — набор инструментов для передачи информации между компонентами системы.

Существуют и другие инструменты, однако в данном примере мы сосредоточимся на использовании только основных компонентов. Наша система будет состоять из трех _устройств_: датчика температуры, нагрузки и графического приложения. Последнее будет позволять управлять нагрузкой и просматривать показания датчика. Все три устройства будут размещены на трех отдельных _модулях_. Можно было бы обойтись и двумя, объединив датчик и нагрузку в одном _модуле_, но мы намеренно их разделим, чтобы продемонстрировать соединение _модулей_ в единую систему.

> [!NOTE]
> Стоит пояснить несколько терминов:
>
> - `Module` — узел системы **_SmartHomeSystem_**, связывающийся с другими по WiFi и запускающий внутри себя одно или несколько устройств.
> - `Device` — устройство системы **_SmartHomeSystem_**, отвечающее за выполнение определенной задачи (физической или виртуальной).
> - `Component` — неделимая составляющая. Под этим термином подразумевается класс, процесс, вычислительный блок или малое устройство (отдельный датчик, соединение, протокол...).
>
> Более подробно ознакомиться с терминологией понятий компонентов **_SmartHomeSystem_** можно в [нужно_вставить]().

Дадим нашим модулям обозначения:

1. `Module_1` — будет отвечать за датчик.
2. `Module_2` — нагрузка.
3. `Module_3` — GUI (графический интерфейс пользователя).

## Аппаратная часть

> “For every problem, there is a solution that is simple, neat, and wrong” — H. L. Mencken

Теперь, когда мы знаем какие именно функции должна выполнять система и из каких частей она будет состоять, можно подобрать необходимые компоненты и спроектировать модули.

### Выбор компонентов

#### Микроконтроллеры

В основе каждого модуля лежит ЭВМ — микроконтроллер или компьютер. Для первого и второго модулей мы будем использовать ESP8266, т.к. проект по большей части рассчитан именно на него. Можно использовать любой из поддерживаемых микроконтроллеров с наличием WiFi: [нужно_вставить]().

> [!TIP]
> Для удобства можно воспользоваться готовыми платами **NodeMCU** или **Wemos D1** — не придется паять лишней обвязки и использовать отдельный программатор.

В качестве `Module_3` будет использоваться персональный компьютер или ноутбук. При желании приложение можно собрать под мобильные устройства, например, телефон.

#### Датчик

Датчик в нашей системе будет измерять показания температуры. Это, наверное, наиболее распространенный пример, который легко повторить — термодатчики дешевые и доступные. При желании, можно взять любой другой датчик, поддерживаемый **_SmartHomeSystem_**, при этом никаких дополнительных изменений (кроме его инициализации в коде первого модуля) в систему вносить не придется!

В качестве датчика температуры будет использоваться обычный терморезистор. Подробно узнать о нем и о других датчиках можно [нужно_вставить]()

#### Нагрузка

В качестве нагрузки мы не будем подключать дополнительные устройства. Ограничимся светодиодом, имеющимся на плате ESP8266. Он связан с портом `GPIO2`, на который, при необходимости, можно подключить настоящую нагрузку.

### Разработка электронной схемы

Следующим шагом необходимо разработать принципиальную электрическую схему. Для этого следует использовать документацию от производителей и материалы из интернета. Некоторую информацию можно найти в документации к аппаратной части проекта[нужно_вставить]().

#### `Module_1`

В нашем случае мы подключаем к аналоговому порту (ADC/A0) первого микроконтроллера делитель напряжения, состоящий из термистора и подтягивающего резистора, номинал которого равен номиналу термистора в нормальных условиях.

<details><summary><b><u>See scheme</u></b></summary>

![scheme_Module_1](guide_data/scheme_Module_1.png)

</details>

#### `Module_2`

Для второго модуля требуется только подать питание на микроконтроллер, т.к. светодиод уже припаян на плате. Для полной картины все-таки приведем схему.

> [!IMPORTANT]  
> Согласно схеме, поведение светодиода инвертировано: он загорается при подаче низкого уровня сигнала (`LOW`) и потухает при подаче высокого уровня (`HIGH`).

> [!WARNING]
> Пины ESP рассчитаны только на логический сигнал. Недопустимо подключать нагрузку, потребляющую более 15 mA. Следует использовать токоограничивающие резисторы.

<details><summary><b><u>See scheme</u></b></summary>

![scheme_Module_1](guide_data/scheme_Module_2.png)

</details>

## Программная часть

> “Talk is cheap. Show me the code.” ― Linus Torvalds

Наконец мы переходим к программным возможностям **_SmartHomeSystem_**!

### Подготовка ПО и сборка

Первым делом следует установить необходимые для работы программы, утилиты и драйверы, а затем запустить сборку проекта. После этого можно приступать к использованию **_SmartHomeSystem_**. Весь этап подробно описан в отдельном файле документации — [build_manual.md](build_manual.md)

### Конфигурация системы

Для начала необходимо создать конфигурацию системы, которая будет едина для всех модулей. С её помощью мы сможем удобно использовать идентификаторы модулей и устройств, избегая копирования файлов и кода, тем самым предотвращая возможные ошибки.

В будущем, планируется реализовать более удобную автоматическую конфигурацию системы, ровно как и дальнейшее создание классов и обработчиков. В данной версии проекта многое придется прописать вручную, однако это пустяки, по сравнению с "голым кодом", который бы пришлось создавать без использования **_SmartHomeSystem_**. Итак, переходим к делу...

Создадим файл [config.h](../../src/examples/guide_system/config.h), в котором укажем конфигурацию всех трех модулей в системе. Теперь, при его подключении в код нам будут доступны следующие константы:

```cpp
shs::config::Module_1::MODULE_ID;                   // value: 1
shs::config::Module_1::DevicesIDs::THERM_SENSOR;    // value: 1

shs::config::Module_2::MODULE_ID;                   // value: 2
shs::config::Module_2::DevicesIDs::LOAD;            // value: 1 

shs::config::Module_3::MODULE_ID;                   // value: 3

```

### Подключение модулей к WiFi

Нам необходимо подключить модули к WiFi-сети, чтобы можно было организовать передачу данных. Для этого в `SHScore` есть специальный класс `shs::ControlWiFi`.

Статическая функция `connectWiFi(ssid, pass)` запустит подключение к WiFi. В нашем случае выполнение какого-либо кода без подключенного WiFi будет бессмысленно, поэтому можно воспользоваться блокирующей функцией `connectWiFiWait(max_time, ssid, pass)`.

Давайте убедимся, что модулю удалось подключиться к WiFi. Для этого выведем отладочную информацию, используя `shs_debug.h`

> [!NOTE]
> Если имя сети и пароль указаны в файле настроек (см. [нужно_вставить]()), то передавать аргументы в функцию необязательно.

```cpp
#include <shs_ControlWiFi.h>

#define DEBUG
#include <shs_debug.h>


void setup()
{
    dinit();

    if (shs::ControlWiFi::connectWiFiWait()) doutln("Wi-Fi is successfully connected.");
    else                                     doutln("WiFi connection error.");
}

void loop() {}

```

### Настройка DTP

Теперь нужно сделать так, чтобы устройство принимало и отправляло данные (запросы с других устройств). Для этого модуль должен уметь:

- Принимать и обрабатывать входящих клиентов.
- Подключаться как клиент к другим устройствам.
- Уметь находить другие модули **_SmartHomeSystem_** в сети.

Для этого в `SHScore` реализован `SHSDTP` — _Smart Home System Data Transfer Protocol_. Он состоит из нескольких компонентов, каждый из которых выполняет свою задачу.

Сначала необходимо создать объект класса `shs::DTP`. Он отвечает за связывание воедино всех шин данных и обработку приходящих по ним сообщений. Чтобы принимать и обрабатывать входящие подключения, необходимо запустить TCP Server. Он реализован в классе `shs::TcpServer`. Серверу нужно передать ссылку на объект `shs::DTP`, таким образом, при подключении нового клиента сервер будет создавать "шину данных" и добавлять ее в хранилище DTP.
Чтобы устройства могли находить друг друга, не зная IP-адресов в локальной сети, разработан класс `shs::DTPdiscover`. Он посылает широковещательный UDP-запрос, на который отвечает искомое устройство, отправляя свой IP-адрес.

> [TIP]
> Вместо подключения всех файлов по отдельности можно воспользоваться их объединением. Достаточно подключить `<shs_DTP>` и `<shs_Network>`.

_Чтобы не загромождать код, был убран вывод отладочной информации._

```cpp
#include <shs_ControlWiFi.h>

#include <shs_DTP.h>
#include <shs_TcpServer.h>
#include <shs_DTPdiscover.h>


shs::DTP dtp(THIS_ID);
shs::TcpServer server(shs::settings::DEFAULT_TCP_PORT, dtp);
shs::DTPdiscover discover(THIS_ID);


void setup()
{
    shs::ControlWiFi::connectWiFiWait();
    
    dtp.start();
    server.start();
    discover.start();
}


void loop()
{
    server.tick();
    dtp.tick();
    discover.tick();
}
```

### Реализация модулей

Теперь, когда связь налажена, можно перейти к реализации отдельно каждого модуля.

#### `Module_1`

Для считывания показаний датчика с аналогового пина предназначен класс `shs::SensorAnalog`. Он получает значение с АЦП, но никак его не обрабатывает. Чтобы получить из показаний АЦП температуру, нужно выполнить специальные преобразования. В [SHSlibrary](../../src/SHSlibrary) для работы с термистором есть специальная библиотека. Класс `shs::Thermistor` наследуется от `shs::SensorAnalog`, при этом он проводит все необходимые вычисления и возвращает уже готовую температуру.

В коде создадим объект термистора, передав в него характеристики используемого компонента. Сразу подключим к нему API, чтобы другие устройства могли запрашивать и получать информацию.

> [!NOTE]
> В качестве датчика не обязательно использовать термистор, можно подключить цифровую микросхему или датчик. Чтобы подружить их с **_SmartHomeSystem_**, достаточно воспользоваться классом, умеющим с ними работать. Если используется не поддерживаемый **_SmartHomeSystem_** датчик, необходимо дописать класс для работы с ним самостоятельно, унаследовав его от `shs::Sensor` (или `shs::SensorAnalog`) и переопределив нужные функции.
>

```cpp
#include <memory>

#include <shs_lib_Thermistor.h>
#include <shs_Sensor_API.h>

shs::Thermistor temp_sensor(A0, 10'000, 3435);
    
// in setup:
dtp.attachAPI(shs::make_unique<shs::Sensor_API>(temp_sensor, shs::ID(THIS_ID, TEMP_SENSOR_ID), dtp));
    
```

#### `Module_2`

Для управления нагрузкой в режиме `SWITCH` (вкл/выкл), аналогично датчику, предоставляется класс `shs::LoadSwitch`. Т.к. поведение светодиода инвертировано, будем использовать `shs::LoadSwitchReversed`. При необходимости плавного регулирования следует использовать `shs::LoadPWM`.

```cpp
#include <memory>

#include <shs_LoadSwitch.h>
#include <shs_Load_API.h>

shs::LoadSwitch load(LED_BUILTIN);

// in setup:
dtp.attachAPI(std::make_unique<shs::Load_API>(load, LOAD_ID));

```

#### `Module_3`

Создание GUI-приложения — задача посложнее. Парой строчек кода обойтись не получится, поэтому реализации третьего модуля посвящен отдельный раздел, следующий ниже.

### Разработка GUI

Для создания приложения будем использовать библиотеку Qt и родную для нее IDE — QtCreator. Более подробно ознакомиться с Qt и научиться писать приложения можно в книге Макса Шлее "Qt5.10. Профессиональное программирование на C++". В данном разделе не будут приводиться подробные объяснения кода Qt, не касающиеся **_SmartHomeSystem_**.

Приложение написано с использованием технологии QtQuick. За бэкенд отвечает класс-движок на С++. Фронтенд использует язык QML. Для удобной интеграции **_SmartHomeSystem_** и Qt разработано вспомогательное ядро [SHSqt_core](../../src/SHSqt_core).

#### Backend

Создадим класс-движок нашего приложения, который будет предоставлять весь необходимый функционал. Ниже приведено объявление класса с основными элементами. Подробную реализацию можно посмотреть в [GUIapp](../../src/examples/guide_system/module_3/GUIapp).

---

Поскольку классы **_SmartHomeSystem_** рассчитаны на работу с паттерном event loop (цикл событий), они требуют постоянного вызова метода `tick()`. Для этого настраивается встроенный в класс `QObject` таймер, по сигналу которого происходят все необходимые опросы.

Для взаимодействия с **QML** в классе объявлены свойства и сигналы. Таким образом, изменения состояний управляемых объектов будут отображаться в графической части.

---

В классе, аналогично предыдущим модулям, созданы два объекта связи:

- `m_discover` отвечает за поиск устройств в сети по ID.
- `m_dtp` связывает шины данных (в нашем случае TCP-соединения), API и виртуальные инструменты.

При запуске приложения происходит попытка найти модули в сети и подключиться к ним. Если подключение состоялось, отправляется соответствующий сигнал `sensorConnectionSignal()` или `loadConnectionSignal()`, который затем отлавливается в части фронтенда.

---

Для получения показаний с датчика и управления нагрузкой созданы виртуальные объекты:

- `m_sensor` — объект виртуального датчика, использующий инструмент `shs::SensorVirtual`, который предоставляет удаленный доступ к датчику с интерфейсом взаимодействия, наследованным от `shs::Sensor`.
Датчик обновляется по таймеру `m_sens_timer`. После получения данных отправляется сигнал `sensorUpdated`.
- `m_load` — объект виртуальной нагрузки, использующий инструмент `shs::LoadVirtual`, который предоставляет удаленное управление нагрузкой с интерфейсом взаимодействия, наследованным от `shs::Load`.

---

<details><summary><b><u>See code</u></b></summary>

```cpp
class Engine : public QObject
{
    Q_OBJECT
public:
    explicit Engine(QObject* parent = nullptr)
    : QObject(parent),
    m_dtp(THIS_ID), m_discover(THIS_ID),
    m_load(THIS_ID, LOAD_ID, m_dtp), m_sensor(THIS_ID, SENSOR_ID, m_dtp)
    {
        start();
    }

    ~Engine() = default;

    void start();
    void tick();
    void stop() {}


    Q_INVOKABLE double   getSensorValue() { return m_sensor.getValueD(); }
    Q_INVOKABLE bool getSensorConnected() { return m_sensor_connected; }
    Q_INVOKABLE bool   getLoadConnected() { return m_load_connected; }

signals:
    void sensorUpdated();
    void sensorConnectionSignal();
    void loadConnectionSignal();

public slots:
    void onSwitchToggled(bool checked) { checked ? m_load.on() : m_load.off(); }
    void timerEvent([[maybe_unused]] QTimerEvent* event) override { tick(); }

private:
    Q_PROPERTY(double sensorValue READ getSensorValue NOTIFY sensorUpdated);
    Q_PROPERTY(bool sensorConnected READ getSensorConnected NOTIFY sensorConnectionSignal);
    Q_PROPERTY(bool loadConnected READ getLoadConnected NOTIFY loadConnectionSignal);

    bool m_checkModuleConnection(const shs::t::shs_ID_t moduleID);

    static constexpr auto THIS_ID = shs::config::Module_3::MODULE_ID;
    static constexpr auto LOAD_ID = shs::t::shs_ID_t(shs::config::Module_2::MODULE_ID, shs::config::Module_2::LOAD);
    static constexpr auto SENSOR_ID = shs::t::shs_ID_t(shs::config::Module_1::MODULE_ID, shs::config::Module_1::THERM_SENSOR);
    static constexpr shs::t::shs_port_t PORT = shs::settings::DEFAULT_TCP_PORT;

    shs::DTP m_dtp;
    shs::DTPdiscover m_discover;

    shs::LoadVirtual m_load;
    bool m_load_connected{};

    shs::SensorVirtual m_sensor;
    bool m_sensor_connected{};

    shs::ProgramTime m_check_connection_timer;
    shs::ProgramTime m_sens_timer;
    bool m_sens_update{};
};

```

</details>

#### Frontend

Для создания виджетов в **_SmartHomeSystem_** подготовлена основа — [SHSqml_core](../../src/SHSqt_core/SHSqml_core).

Для каждого виджета задаются свойства `moduleName` — имя соответствующего модуля и `isConnected` — статус соединения. При успешном подключении, виджет помечается _connected_.

Помимо виджетов, создается объект класса-движка (`SHSengine`). Его слоты настраиваются на изменение виджетов.

<details><summary><b><u>See code</u></b></summary>

```qml
import QtQuick 2.12
import QtQuick.Window 2.12
import QtQuick.Controls 2.12
import QtQuick.Controls.Material 2.12
import QtQuick.Controls.Styles 1.4
import QtQuick.Layouts 1.12

import SHSengine 1.0
import "./SHSbuild/SHSqt_core/SHSqml_core"


ApplicationWindow {
    visible: true

    width: 640
    height: 480
    property int defMargin: 20
    minimumWidth: columnLayout.implicitWidth + 2*defMargin
    minimumHeight: columnLayout.implicitHeight + 2*defMargin

    title: qsTr("Smart Home System")
    Material.theme: Material.Dark
    Material.background: "#001219"


    ColumnLayout {
        id: columnLayout
        anchors.centerIn: parent
        anchors.fill: parent
        spacing: defMargin / 2


        Load {
            id: load
            Layout.fillWidth: true
            Layout.margins: defMargin

            onChanged: shs_engine.onSwitchToggled(checked)
        }

        Sensor {
            id: sensor
            Layout.fillWidth: true
            Layout.margins: defMargin
        }

        Item {
            Layout.fillHeight: true
            Layout.minimumWidth: 280
        }
    }

    SHSengine {
        id: shs_engine
        onSensorUpdated: sensor.value = sensorValue
        onSensorConnectionSignal: sensor.isConnected = sensorConnected
        onLoadConnectionSignal: load.isConnected = loadConnected
    }
}
```

</details>

#### Скриншот приложения

![GUIapp_screenshot](../../schemes/GUIapp_from_guide_screenshot.png)
